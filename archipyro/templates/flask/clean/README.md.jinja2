# {{ config.name }}

Generated by ArchiPyro.

## Framework
{{ config.framework }}

## Architecture
{{ config.architecture }}

## Features
{% for feature in config.features %}
- {{ feature }}
{% endfor %}

## Setup

### 1. Create Virtual Environment
It is recommended to use a virtual environment to manage dependencies.

```bash
# Create virtual environment
python3 -m venv venv

# Activate virtual environment
# On Linux/macOS:
source venv/bin/activate
# On Windows:
# venv\Scripts\activate
```

### 2. Install Dependencies
```bash
pip install -r requirements.txt
```

### 3. Environment Variables
A `.env` file has been generated for you. Review it and update any necessary variables (e.g., Database URL, Secret Key).

## Configuration
The application configuration is managed in `app/config`. You can change the active configuration by setting the `FLASK_ENV` environment variable or by modifying `app/__init__.py`.

Available configurations:
- `development` (default)
- `testing`
- `production`

{% if config.database in ['PostgreSQL', 'MySQL', 'SQLite'] %}
## Database Setup

This project uses **Flask-SQLAlchemy** for ORM and **Flask-Migrate** (Alembic) for database migrations.

### 1. Configure Database Connection

Update your `.env` file with your database credentials:

{% if config.database == 'PostgreSQL' %}
```env
DATABASE_URL=postgresql://username:password@localhost:5432/{{ config.slug }}
```
{% elif config.database == 'MySQL' %}
```env
DATABASE_URL=mysql+pymysql://username:password@localhost:3306/{{ config.slug }}
```
{% elif config.database == 'SQLite' %}
```env
DATABASE_URL=sqlite:///{{ config.slug }}.db
```
{% endif %}

### 2. Initialize Migrations

If this is a new project, initialize the migrations folder:

```bash
flask db init
```

**Note:** If migrations folder already exists, skip this step.

### 3. Create Initial Migration

Generate the first migration based on your models:

```bash
flask db migrate -m "Initial migration"
```

This will create a migration file in `migrations/versions/`.

### 4. Apply Migrations

Apply the migration to create tables in your database:

```bash
flask db upgrade
```

### 5. Verify Database

Your database tables should now be created. You can verify by connecting to your database.

### Common Migration Commands

```bash
# Create a new migration after model changes
flask db migrate -m "Description of changes"

# Apply pending migrations
flask db upgrade

# Rollback last migration
flask db downgrade

# Show current migration status
flask db current

# Show migration history
flask db history
```

### Migration Workflow

1. **Modify your models** in `app/models/`
2. **Generate migration**: `flask db migrate -m "Add new field"`
3. **Review migration file** in `migrations/versions/`
4. **Apply migration**: `flask db upgrade`

### Official Documentation

- [Flask-SQLAlchemy](https://flask-sqlalchemy.palletsprojects.com/)
- [Flask-Migrate](https://flask-migrate.readthedocs.io/)
- [Alembic](https://alembic.sqlalchemy.org/)

{% elif config.database == 'MongoDB' %}
## Database Setup

This project uses **MongoEngine** for MongoDB ODM.

### 1. Configure MongoDB Connection

Update your `.env` file with your MongoDB connection string:

```env
MONGODB_URL=mongodb://localhost:27017/{{ config.slug }}
```

### 2. Create Indexes

MongoEngine will automatically create collections when you insert data. To create indexes defined in your models:

```python
# Run this once after starting your app
from app import create_app
from app.extensions import db

app = create_app()
with app.app_context():
    # This creates indexes defined in model meta
    db.connection.admin.command('ping')
```

### 3. No Schema Migrations Needed

MongoDB is schema-less, so traditional migrations aren't required. However, if you need to transform existing data:

1. Create a Python script in a `migrations/` folder
2. Connect to MongoDB
3. Update documents as needed

### Official Documentation

- [MongoEngine](http://mongoengine.org/)
- [PyMongo](https://pymongo.readthedocs.io/)

{% endif %}

## Run Application

```bash
flask run
```

{% if 'Celery / RQ Background Tasks' in config.features %}
## Background Tasks with Celery

This project includes Celery for handling asynchronous background tasks.

### Project Structure
```
app/
├── extensions/
│   └── celery.py      # Celery configuration with Flask app context
├── tasks/
│   ├── __init__.py    # Import all task modules here
│   └── example.py     # Example tasks
```

### Start Redis (Required)
```bash
# Using Docker
docker run -d -p 6379:6379 redis:7-alpine

# Or if Redis is installed locally
redis-server
```

### Start Celery Worker
```bash
celery -A celery_worker.celery worker --loglevel=info
```

### Start Celery Beat (for scheduled tasks)
```bash
celery -A celery_worker.celery beat --loglevel=info
```

### Adding New Tasks

1. **Create a new task file** in `app/tasks/` (e.g., `email.py`):
   ```python
   from app.extensions.celery import celery
   
   @celery.task(name='app.tasks.email.send_welcome_email')
   def send_welcome_email(user_id):
       # Your task logic
       return f"Welcome email sent to user {user_id}"
   ```

2. **Import it in `app/tasks/__init__.py`**:
   ```python
   from app.tasks.example import *  # noqa
   from app.tasks.email import *    # noqa  <-- Add this line
   ```

3. **Tasks are automatically discovered** - restart Celery worker to see them

### Using Tasks
```python
from app.tasks.example import send_email_task

# Queue a task
result = send_email_task.delay('user@example.com', 'Subject', 'Body')

# Check if done
if result.ready():
    print(result.get())
```

See `CELERY_GUIDE.md` for detailed documentation.

{% endif %}

{% if "Docker" in config.features %}
## Docker Support

You can also run the application using Docker.

```bash
docker-compose up --build
```
{% endif %}

